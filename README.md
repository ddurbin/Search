Search
======
This program maps an inverted index using the Indexer program. Then the indexer can be searched for tokens in one or more files in a given directory.


! To run the program, the make command creates executables for both the indexer and search. We then run the indexer program giving it the desired directory. We then run search giving it the inverted index file outputted by the indexer. Then the on screen directions shown by the search program can be followed.!
!
Design:!
!
! The base design for the search program is a prefix tree. Each array node in the tree has 36 positions, representing 0-9 and a-z. Each array node position also has a boolean value which is set true when that place in the tree represents a word from the inverted index. They all also have a pointer to a linked list of nodes that each hold a name of a file that contains the word represented by that specific tree location, a pointer to its child array node, and a pointer to its parent which is a specific position in and array node.!
! For keeping track of the search results, we use a linked list of “file nodes”. This node stores a file name, a count of how many of the searched terms exists in the file, and a pointer to the next “file node”. When a searched term exists in the inverted index, we add its files to the linked list, or increment the file counter if that file is already in the linked list. If the search is an “sa”, then for the first searched term, its file list is duplicated as the result files list, and then each addition terms list of files is then compared to the result list. If it exists, that files count is incremented, if not, we don’t add that file to the list. The counter is how we perform the “sa” search correctly. We keep track of how many total terms were searched, and when it comes time to print out the results for an “sa” search, only the files whose counter is equal to the count of total terms is printed out.!
! The inverted index output has stayed the same as in the last assignment, that is we still obtain all the tokens and their associated files and frequencies. However, once the search program is called on the output index text file, the frequencies are ignored and reset to hold the number of occurrences in certain files for the "sa" search option.! !
Efficiency:!
! For the searching algorithms there exists only a few operations which have a big impact on the Big O notation of the program. First, we have building the prefix tree, which consists of adding each token from the index file. Second, we have searching the tree for a specific token. Third, we have duplicating the linked lists for the first token as well as appending the file node onto the link list. Lastly, we have freeing the memory for the entire tree structure upon completion.!
! Big O analysis for building the tree: for each token insertion into the tree assuming the length of the token to be k, at each character k in the token we would
￼need retrieve the hash function and determine if there exists a node in the index of the hash function of the children array. So, for each character k, there will be 1 comparison to determine whether to not to create a node. Therefore, that would be o(k*1), which results in a Big O of O(1), or constant time. However, if we assume there is n tokens, to map the all the tokens to the tree, the big O would be n * O(1). Overall, the Big O to map all the tokens to the tree is O(n), where n is the number of tokens in the index file.! ! Big O notation for searching the tree: This is almost identical to the analysis of insertion into the tree. For each character of the token we would need to compare the boolean value is_word. Therefore, the Big O notation is O(1) for searching for a word.!
! Big O notation for duplicating the linked list: If we assume the total number of files for the inverted index to be n, then worst case is there exists a word which occurs in all the files. Therefore, we would need to duplicate each node of the file linked list resulting in a Big O of O(n). For the "sa" search once we duplicate the first token file list, each additional token file would need to be compared to the entire first token list. If we assume the file list’s to be of length n and we assume the number of token arguments to be m. Then for each token after the first there would need to be n*m comparisons, worst case none of the tokens files after the first exist in the list. So, the overall analysis would be n*m + n*m + n*m +......for each token argument, which results in a Big O of O(n*m).! ! Big O analysis for freeing the tree: Assuming we have a tree which has the longest word of n where each of the previous nodes children are full and each of those nodes contains a linked list of files of length m. The analysis would be log base 32 of (n +m). So, we would take the worst case of m or n depending on which is greater the number of files at each node or the longest word. So the Big O notation for freeing the e!ntire tree would be O(log36(n+m)), where we take the greater of m or n.!
! Space Requirements: For our searching program the amount of space requirements for storing the prefix tree will depend on 3 things. One is the alphanumeric size of the children array for each node, which is 36. Second, is the length of the token, m, assuming all tokens are worst case the same length. Third, is the number of tokens that must be inserted into the tree, n. So, the overall memory requirements for the entire tree will be O(36*m*n).!
!
